{"version":3,"sources":["getWeb3.js","App.js","serviceWorker.js","index.js"],"names":["getWeb3","Promise","resolve","reject","window","addEventListener","a","ethereum","web3","Web3","enable","console","log","provider","providers","HttpProvider","AppComponent","useState","setWeb3","accounts","setAccounts","setTokenContract","tokenSaleContract","setTokenSaleContract","saleTotalSupply","tokenSold","tokenPrice","purchaseQuantity","userBalance","values","setValues","isProcessingTxn","setIsProcessingTxn","toast","useToast","useEffect","eth","getAccounts","net","getId","networkId","BTDTokenNetwork","BTDTokenContract","networks","BTDTokenSaleNetwork","BTDTokenSaleContract","btdToken","Contract","abi","address","btdTokenSale","methods","call","balanceOf","prevState","events","Sell","on","event","title","description","returnValues","status","duration","isClosable","err","alert","message","error","buyToken","send","from","value","gas","maxW","sx","display","alignItems","justifyContent","flexDirection","height","borderWidth","borderRadius","padding","background","position","shadow","className","thickness","speed","emptyColor","color","size","top","left","zIndex","mb","marginTop","disabled","pr","type","placeholder","onChange","e","persist","Number","target","width","h","onClick","fontSize","marginBottom","App","style","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7ca30987.chunk.js","sourcesContent":["import Web3 from \"web3\";\n\nconst getWeb3 = () =>\n  new Promise((resolve, reject) => {\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\n    window.addEventListener(\"load\", async () => {\n      // Modern dapp browsers...\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum);\n        try {\n          // Request account access if needed\n          await window.ethereum.enable();\n          // Accounts now exposed\n          resolve(web3);\n\n        } catch (error) {\n          reject(error);\n        }\n      }\n      // Legacy dapp browsers...\n      else if (window.web3) {\n        // Use Mist/MetaMask's provider.\n        const web3 = window.web3;\n        console.log(\"Injected web3 detected.\");\n        resolve(web3);\n      }\n      // Fallback to localhost; use dev console port by default...\n      else {\n        const provider = new Web3.providers.HttpProvider(\n          \"http://127.0.0.1:8545\"\n        );\n        const web3 = new Web3(provider);\n        console.log(\"No web3 instance injected, using Local web3.\");\n        resolve(web3);\n      }\n    });\n  });\n\nexport default getWeb3;\n","import React, { Component, useEffect, useState } from \"react\";\nimport BTDTokenContract from \"./contracts/BTDToken.json\";\nimport BTDTokenSaleContract from \"./contracts/BTDTokenSale.json\";\nimport getWeb3 from \"./getWeb3\";\n\nimport { Alert, AlertIcon, Box, Button, Center, ChakraProvider, Container, Divider, Heading, Input, InputGroup, InputRightElement, Progress, Spinner, Text, useToast } from '@chakra-ui/react'\n\nimport \"./App.css\";\n\nconst AppComponent = () => {\n\n  const [web3, setWeb3] = useState(null)\n  const [accounts, setAccounts] = useState([])\n  const [tokenContract, setTokenContract] = useState(null)\n  const [tokenSaleContract, setTokenSaleContract] = useState(null)\n  const [values, setValues] = useState({\n    saleTotalSupply: 888888,\n    tokenSold: 0,\n    tokenPrice: 0,\n    purchaseQuantity: 0,\n    userBalance: 0,\n  })\n  const [isProcessingTxn, setIsProcessingTxn] = useState(false)\n  const toast = useToast()\n\n  const { saleTotalSupply, tokenSold, tokenPrice, purchaseQuantity, userBalance } = values\n  useEffect(() => {\n    (async function () {\n      try {\n        // Get network provider and web3 instance.\n        const web3 = await getWeb3();\n\n        // Use web3 to get the user's accounts.\n        const accounts = await web3.eth.getAccounts();\n\n        // Get the contract instance.\n        const networkId = await web3.eth.net.getId();\n        // const networkId = 5777\n\n        const BTDTokenNetwork = BTDTokenContract.networks[networkId];\n        const BTDTokenSaleNetwork = BTDTokenSaleContract.networks[networkId];\n\n        const btdToken = new web3.eth.Contract(\n          BTDTokenContract.abi,\n          BTDTokenNetwork && BTDTokenNetwork.address,\n        )\n\n        const btdTokenSale = new web3.eth.Contract(\n          BTDTokenSaleContract.abi,\n          BTDTokenSaleNetwork && BTDTokenSaleNetwork.address,\n        )\n\n        const tokenPrice = await btdTokenSale.methods.tokenPrice().call()\n        const tokenSold = await btdTokenSale.methods.tokenSold().call()\n        const userBalance = await btdToken.methods.balanceOf(accounts[0]).call()\n\n        setWeb3(web3)\n        setAccounts(accounts)\n        setTokenContract(btdToken)\n        setTokenSaleContract(btdTokenSale)\n\n        setValues(prevState => ({ ...prevState, tokenPrice }))\n        setValues(prevState => ({ ...prevState, tokenSold }))\n        setValues(prevState => ({ ...prevState, userBalance }))\n\n        // btdTokenSale.events.Sell({}, { fromBlock: 'latest', toBlock: 'latest' })\n        btdTokenSale.events.Sell()\n          .on(\n            'data', async (event) => {\n              console.log({ event })\n              const tokenSold = await btdTokenSale.methods.tokenSold().call()\n              const userBalance = await btdToken.methods.balanceOf(accounts[0]).call()\n              toast({\n                title: 'Token Purchased.',\n                description: `You have successfully purchase ${event.returnValues[1]} BTD token`,\n                status: 'success',\n                duration: 3000,\n                isClosable: true,\n              })\n              setValues(prevState => ({ ...prevState, tokenSold }))\n              setValues(prevState => ({ ...prevState, purchaseQuantity: 0 }))\n              setValues(prevState => ({ ...prevState, userBalance }))\n              setIsProcessingTxn(false)\n            }\n          ).on(\n            'changed', (event) => {\n            }\n          ).on('error', (err) => alert(err.message))\n\n        // const balance = await btdToken.methods.balanceOf(BTDTokenSaleNetwork.address).call()\n\n        return () => { }\n      } catch (error) {\n        alert(\n          `Failed to load web3, accounts, or contract. Check console for details.`,\n        );\n        console.error(error);\n      }\n    })()\n  }, [])\n\n  const buyToken = async () => {\n    try {\n      setIsProcessingTxn(true)\n      await tokenSaleContract.methods.buyToken(purchaseQuantity).send({\n        from: accounts[0],\n        value: purchaseQuantity * tokenPrice,\n        gas: 500000 // gas limi\n      })\n    } catch (err) {\n      setIsProcessingTxn(false)\n      toast({\n        title: 'Something went wrong.',\n        description: `Failed to purchase token, please try again later.`,\n        status: 'error',\n        duration: 3000,\n        isClosable: true,\n      })\n    }\n  }\n\n  if (!web3) {\n    return <div>Loading Web3, accounts, and contract...</div>;\n  }\n  return (\n    <Container\n      maxW='container.md'\n      sx={{\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-around',\n        flexDirection: 'column',\n        height: '100vh'\n      }}\n    >\n      <Box\n        borderWidth='1px' borderRadius='lg'\n        padding={20}\n        background={'#FFF'}\n        position={'relative'}\n        shadow={'1px 1px 10px 1px #000'}\n        className=\"App\"\n      >\n        {\n          isProcessingTxn ? (\n            <Spinner\n              thickness='4px'\n              speed='0.65s'\n              emptyColor='gray.200'\n              color='blue.500'\n              size='xl'\n              position={'absolute'}\n              top='48%'\n              left='48%'\n              zIndex={3}\n            />\n          ) : null\n        }\n        {\n          tokenSold >= saleTotalSupply ? (\n            <>\n              <Heading mb={4}>Token Sale End</Heading>\n              <Text>\n                You currently have {userBalance} BTD\n              </Text>\n            </>\n          ) : (\n            <>\n              <Heading mb={4}>BTD Token Sale</Heading>\n              <Text>\n                Introducing \"Buy This Dump Coin (BTD)\"! Token price is 0.001 Ether. You currently have {userBalance} BTD\n              </Text>\n              <InputGroup size='md' marginTop={'30px'}>\n                <Input\n                  disabled={isProcessingTxn}\n                  pr='4.5rem'\n                  type={'number'}\n                  placeholder='Amount'\n                  value={purchaseQuantity}\n                  onChange={(e) => {\n                    e.persist()\n                    setValues(prevState => ({ ...prevState, purchaseQuantity: Number(e.target.value) }))\n                  }}\n                />\n                <InputRightElement width='4.5rem'>\n                  <Button h='1.75rem' size='sm' onClick={buyToken} zIndex={1} disabled={isProcessingTxn}>\n                    {'Buy'}\n                  </Button>\n                </InputRightElement>\n              </InputGroup>\n\n              <Progress value={(tokenSold / saleTotalSupply) * 100} marginTop={'40px'} borderRadius={'sm'} />\n              <Text marginTop={'20px'}>{tokenSold} / {saleTotalSupply} Tokens Sold</Text>\n              <Alert marginTop={'30px'} fontSize={'sm'} color={'#3182CE'} borderRadius={'sm'} status='info'>\n                <AlertIcon />\n                This token sale uses the Rinkeby Test Network with fake ether. Use a browser extension like Metamask to connect to the test network and participate in the ICO. Please be patient if the test nework runs slowly.\n              </Alert>\n\n              <Divider marginTop={'30px'} marginBottom={'30px'} />\n              <Text>Your Account: {accounts[0]}</Text>\n            </>\n          )\n        }\n\n      </Box>\n    </Container >\n\n  );\n}\n\nconst App = () => {\n  return (\n    <ChakraProvider>\n      <main style={{ background: '#1A202C' }}>\n        <AppComponent />\n      </main>\n    </ChakraProvider>\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}